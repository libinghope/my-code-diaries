---
date: 2020/3/1
comments: true
categories:
  - 操作系统
tags:
  - 操作系统
  - 进程
  - 同步
  - 信号量
permalink: '3.17'
title: 信号量的临界区保护
---

由于信号量是共享数据，生产者和消费者都会访问和修改信号量的内容，有可能在时间片中断的时候造成信号量
的错误。

临界区的概念，一次只允许一个进程进入的进程的那一段代码。

读写临界区的代码一定是临界区。——这一段代码是原子操纵。

如何保护信号量？保护的原则,互斥，有空进入，有限等待。
最直观的想法 轮换法：

进程1

```c++
while(turn !=0)
{
  //临界区代码
}
turn = 1;
```

进程2

```c++
while(turn !=1)
{
  //临界区代码
}
turn = 1;
```

以上这种方法很明显会造成资源的浪费，当进程2去IO了，临界区限制，进程1依然无法进入临界区执行。

Peterson算法(两个进程可以正确处理)

![image.png](https://i.loli.net/2020/03/15/gdGLikxWrS7Zhm3.png)

多个进程的处理办法？面包店算法

![image.png](https://i.loli.net/2020/03/15/GeY5d1bu96kyZKx.png)

以上方法都是软件的实现方式，计算机还提供了硬件的支持 INTR寄存器，时间中断寄存器。
在进入临界区前调用cli();//禁止时钟中断  执行完出了临界区调用sti();重新开启时钟中断。
但是多CPU仍然会有问题。

硬件原子指令方法：

```c++
boolean TestAndSet(boolean &x){
  boolean rv =x;
  x = true;//上锁
  return rv;//rv是x原来的值
}
```

上述代码必须要么不执行，要么一次执行完。  

总结，有临界区保护信号量，信号量来实现进程的同步。
