---
date: 2020/3/11
comments: true
categories:
  - 软件架构
tags:
  - 架构
  - 复杂度
permalink: "5.4"
title: 高可用带来的软件复杂度
---
上篇文章讲了高性能带来的复杂度，这篇来探讨一下高可用带来的软件复杂性。
首先，得知道什么叫高可用，根据维基百科的定义，高可用指的是系统无中断的执行其功能的能力，代表系统的可用性程度是进行系统设计时的准则之一。
这里无中断指的是，软件在运行的时候不受外部环境或者内部环境的影响，例如断电，断网，水灾，地震，这些事故系统依然可以使用。为了解决这些问题，将不可避免地增加软件架构的冗余度。比如说为了解决断电的情况下依然可用，那么就需要提供备用的电源。
通过冗余增强了软件系统的可用性，但也同事带来了复杂性。

## 一 计算高可用

计算高可用的意思就是说，我们的软件系统无论在哪一台电脑上，对于相同的算法和输入数据得出的输出结果必然是一样的，也就是说软件系统可以随意的在机器之间进行迁移，并不会对业务产生什么影响。
通常情况下解决这种问题都是通过增加备用的计算服务器来实现的。增加额外的计算服务器，这个方法带来的复杂度跟上一篇文章当中的双机服务器是一样的(如下图)，不再赘述。
![image.png](https://i.loli.net/2020/03/16/Ed53Z2iYnx6Pqkt.png)

同样的也可以对高可用使用计算服务器集群的方法，这样就业跟上一篇中提到的多系统服务器一样增加了复杂度。不仅如此，这里的分配算法比之前的业务服务器集群更加复杂，因为这时候(如下图所示)可能是一主三备，二主二备，三主一备，4主零倍，具体采用哪种方式应该结合实际业务需求来分析和判断，并不存在一种最优算法。例如zoo keeper采用的就是一主多备，而memcached的采用的是全主0备。
![image.png](https://i.loli.net/2020/03/16/Myc6iEpFvHOUsKk.png)

## 二 存储高可用

存储高可用的意思就是说对一个软件系统，数据可以在多台机器之间进行传输保证实时性和一致性。关键是传输基本上都是通过网络线路进行传输的，由于地理空间等因素的影响，这个传输过程是有可能在几毫秒甚至上百毫秒延迟的，不稳定的情况，甚至可以达到几秒甚至更多。虽然几十毫秒对于人来说几乎没有什么感觉，但是对于高可用系统来说，就是本质上的不同，这意味着整个系统在某个时间点上数据肯定是不一致的，这在某些情况下很可能会给用户带来非常不好的体验。例如一个银行客户在账户内存入1万块钱此时用的北京的机房，他存完之后马上查询，查询的时候结果被路由到了上海机房，上海机房和北京机房同步需要一段时间，时间虽然很短，但是在这段时间内，他的账户内是没有刚才存入的一万块钱的，他肯定会觉得自己是不是被骗了。
![image.png](https://i.loli.net/2020/03/16/W1xBjheQlpFiPKc.png)
总之存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。

## 三 高可用状态决策

无论是计算高可用还是存储高可用，其基础都是状态决策及系统能够判断当前的状态是正常还是异常，如果出现了一场怎样采取行动启用我们那个冗余的备用方案。嗯，但是这里有一个很明显的矛盾，就是通过荣誉来实现的高可用系统状态决策，本质上就不可能做到完全正确。常见的决策算法有独裁式的，协商式的，民主式的等等。但是无论采用什么样的决策方案，状态角色都不可能做到任何场景下都没有问题，但完全不做高可用方案又会产生更大的问题，如何选取适合折中的可靠性方案，也是一个复杂的分析判断选择过程。
