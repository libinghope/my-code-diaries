---
title: 计算机网络基础知识2
date: 2020/3/15
comments: true
categories:
  - linux
tags:
  - 协议格式
  - 网络协议
permalink: "6.8"
---
## 协议格式

### 数据报封装

通常传输层以下的通信机制由操作系统来提供，主流的操作系统都安装有TCP/IP协议。应用层的功能由用户的进程提供，应用层程序对通讯的数据进行解释，使之成为能够被理解使用的数据。当数据从一台计算机传输到另外一台计算机的时候，每层协议都要给数据加上一个首部——header，这个过程成为数据的封装。如下图所示为TCP/IP数据报传输过程的封装

![TCP/IP数据报的封装](https://pic.downk.cc/item/5eb4b8a6c2a9a83be5192193.jpg)

不同的协议层对数据包有不同的称谓，在传输层叫做段(segment),在网络层叫做数据报(datagram),在链路层叫做帧(frame).数据封装成帧后发布到传输介质上，到达目的主机后每层协议在剥掉响应的首部，最后将应用数据交给应用程序处理。

### 以太网帧格式

如下图所示

![以太网帧格式](https://pic.downk.cc/item/5eb4b995c2a9a83be519fdd5.jpg)

其中的源地址和目的地址是指网卡的MAC地址；协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。

帧数据的数据长度为46字节，最大为1500字节，ARP和RARP的数据包长度不够46字节，要在后面补充填充位。长度大于1500的需要对数据包进行分片。

### IP数据报格式

![IP数据报格式](https://pic.downk.cc/item/5eb4bba4c2a9a83be51bbb9f.jpg)

IP数据报的首部长度和数据长度都是可变的，但总是4字节的整数倍。对于IPv4,4为版本字段是4.4位首部长度的数值是以4字节为单位的，最小值为5，也就是首部的最小长度是4*5=20字节。最大长度就是2的4次方减一(从0开始)，然后乘以4等于60字节。8位TOS字段有3位来指定IP数据报的优先级(目前已经废弃不用了)。还有4位表示可选的服务类型(最小延迟，最大吞吐，最大可靠性，最小成本)。还有一个位总是为0.

总长度是整个数据报的的字节数，包括IP首部和IP层payload的字节数。每传一个数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。

TTL表示经过的最大的路由次数，每经过一个路由器就把该值减一，如果减到0了，还没找到目标主机就丢弃该包。因此这个生存时间值得不是时间，而是数据在中间路由器跳(hop)了多少次。

协议字段指示上层协议是TCP、UDP、ICMP、还是IGMP.然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。

### UDP数据报格式

![UDP数据报](https://pic.downk.cc/item/5eb4bf15c2a9a83be51e7734.jpg)

UDP数据报格式相对简单。UDP协议不面向连接，不保证传输的可靠性。发送端的UDP协议只管把应用程序传过来的数据封装成段，交给IP协议就算完成传输任务了。如果因为网络故障，该段无法到达目标计算机，UDP也不会给应用层返回任何错误信息。QQ聊天就是用的UDP传输，最开始比较早的版本即便发送文字消息失败，QQ也不会做任何提示，后来应该是腾讯在应用层做了处理，UDP发送失败也会有发送失败的提醒。

### TCP数据报格式

如下图所示
![TCP数据段](https://pic.downk.cc/item/5eb4c099c2a9a83be51f92a1.jpg)

与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小稍后详细解释。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位。其他字段后面再说。

### TCP协议

TCP的通讯时序如下图所示

![TCP通讯时序](https://pic.downk.cc/item/5eb4c1d5c2a9a83be5209042.jpg)

在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。

关闭连接的过程——4次握手：

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。当一方完成它的数据发送任务后就发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

如上图所示

1. 客户端发出段7，FIN位表示关闭连接的请求。
2. 服务器发出段8，应答客户端的关闭连接请求。
3. 服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。
4. 客户端发出段10，应答服务器的关闭连接请求。

建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。

**滑动窗口机制**如下图所示

![滑动窗口机制](https://pic.downk.cc/item/5eb4cec1c2a9a83be52a84ff.jpg)

1、发送端：我能接收的最大数据段长度为1460(mss=1460),初始序号为0，你一次发送的数据别超过当前窗口大小4K(win=4096)。

2、接收端：好的收到(ACK)，我这边能接收的最大数据段长度为1024(mss=1024),我当前的窗口大小是6K(win=6144)，我们发送数据时候初始序号用8000吧。

3、发送端：好的收到(ACK),现在回复8000号数据，序号是8001，然后再发出4-9段的数据(就是6k数据)，填满接收端窗口，停止发送数据

4、接收端从缓冲区拿走(处理)2k数据,这边又有2k的窗口了，发出段10，应答已经收到了6K数据(ACK6145)，接收端程序又拿走了2K的数据，重新声明窗口大小为4k

5、发送端发出段12-13，每个段带2k数据，段13同时包含FIN位

6、接收端接收到2k的数据，再加上FIN位，回应的是8193，序号为8194，连接处于半关闭状态，接收端声明窗口大小为2k

7、接收端拿走2k数据，重新声明窗口大小为4k

···

直到最后，接收端的应用程序拿走所有数据后，决定关闭连接，发出段17，并包含FIN位，发送端应答，连接完全关闭。

**TCP的状态转换**
![TCP状态转换](https://pic.downk.cc/item/5eb4d398c2a9a83be52ee9d8.jpg)

CLOSED：表示初始状态。

LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。

SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。

SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。

ESTABLISHED：表示连接已经建立。

FIN_WAIT_1:  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：

FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。
FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。

FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。

TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。

CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。

CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。

LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。

其中TIME_WAIT状态，如果server端如果主动关闭了连接，那么server端就会处于，TIME_WAIT状态，TCP协议规定需要等两个MSL之后才能回到CLOSED状态。而在这期间，server端的端口是不能被重新监听的。

通常为了防止TCP异常断开，会采用心跳检测机制。就是定时发送一个代表心跳的数据报，来检测对方是否实时在线。

### 相关术语

路由:
数据报从源地址到目标地址所经过的路径。有时候“路由”也用作动词，表示为数据报选择传输方向的过程。

路由表：

计算机网络中，路由表或称路由择域信息库（RIB）是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径。

路由条目：
路由表中的一条数据，每个条目主要由目的网络地址、子网掩码、下一跳地址、发送接口四部分组成，如果要发送的数据包的目的网络地址匹配路由表中的某一行，就按规定的接口发送到下一跳地址。

缺省路由条目：
路由表中的最后一条记录，主要由下一跳地址和发送接口两部分组成，当目的地址与路由表中其它行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址。

路由节点：
一个具有路由能力的主机或路由器，它维护一张路由表，通过查询路由表来决定向哪个接口发送数据包。

半双工/全双工：
Full-duplex（全双工）全双工是在通道中同时双向数据传输的能力。
Half-duplex（半双工）在通道中同时只能沿着一个方向传输数据。

DNS服务器:
解析域名地址的服务器，简单的来说，就是把我们常用的网址对应成相应的IP地址。

广域网：
通常我们说的“上网”，就是指的广域网，把不同地区、城市和国家质检连接起来的计算机网络。

端口：
通常所说的端口，就是指TCP/IP协议中的端口。端口号的范围从0到65535(16位)。
