---
date: 2020/2/25
comments: true
categories:
  - 操作系统
tags:
  - 操作系统
  - 线程
permalink: '3.12'
title: 内核级线程的代码实现
---
这一课主要讲线程切换的代码实现方法，总共没几句核心代码。感觉老师的讲授方式不太对，切换线程很大程度上就是对  应栈的切换，更基本的就是说指令的跳转，既然要跳转，肯定要进行“现场保护”，才方便以后还可以跳回来继续执行，  “现场保护”的操作基本就是固定的，就是寄存器压栈，我们应该站在这个基础上来理解线程的切换。可是老师每次都要把  
入栈出栈的具体过程讲一下，相当于每次都是从第一阶台阶讲起。作为老师应该，主动帮学生总结出来“台阶”，下节课就  站在前一节顶点台阶上继续，而不是像现在这样，纠结于栈中保存的数据到底是什么，到底指向哪里。  

如果从这个角度站在跳转时“现场保护”的基础上去看线程切换，就非常简单了。  
关键就在于ThreadCreate的过程了。  
![ThreadCreate.png](https://i.loli.net/2020/03/10/5Ooq7BvrRcaumMi.png)

在_sys_fork中会调用_copy_process,复制父进程，一个新的进程开始会创建自己的PCB和两个栈(用户栈和内核栈)，当然PCB肯定是和自己的栈相关联的。  
![image.png](https://i.loli.net/2020/03/10/H3PawGkSfyRJDOg.png)

老师还讲了copy_process的执行前准备，还是那句话，本质就是指令的跳转，保存正在执行的，找到将要执行的。根本不用讲寄存器到底赋值了多少。  
![image.png](https://i.loli.net/2020/03/10/2nDJspIATyx41Eg.png)

系统如何执行我们想要的代码(程序)

![image.png](https://i.loli.net/2020/03/10/2nDJspIATyx41Eg.png)

当fork返回0后，找到我们指定的要执行的程序的入口，即main函数地址,保存现场，执行我们的程序，返回现场继续执行。