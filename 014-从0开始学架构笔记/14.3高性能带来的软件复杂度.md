---
date: 2020/3/10
comments: true
categories:
  - 软件架构
tags:
  - 架构
  - 复杂度
permalink: "5.3"
title: 高性能带来的软件复杂度
---

计算机硬件计算速度的超高速发展，体现了人们对高性能的追求。著名的摩尔定律,即计算机的硬件计算能力会在18个月内翻一番。由于计算机硬件的计算能力的提升，软件系统也得到了飞速的发展，从最初的计算机只能进行简单的科学计算，到现在谷歌能够进行每秒几万次的搜索。与此同时软件系统规模也从单台计算机扩展到了上万台计算机，从最初的单用户当中的字符界面dos操作系统到现在的多用户多功能windows10图形界面操作系统。

软件系统的飞速发展导致了非常多全新领域的新技术出现，但是这些新技术并不是说像硬件一样，新技术取代旧带的技术，而是说我们在进行软件设计的时候，需要在这些技术之间进行选择和组合，就如同汽车的发明无法取代火车，飞机的出现也无法取代汽车一样，我们在出行的时候需要考虑选择汽车，火车还是飞机，这个要统筹考虑价格，时间，速度，舒适度等各种因素。

## 单机复杂度

计算机内部复杂度最关键的地方就是操作系统，如前所说操作系统一路发展下来，到了现在多进程多线程，多CPU能够同时执行。

而我们开发的软件是要基于操作系统进行运行的，所以我们要完成一个高性能的软件系统，就必须要考虑到操作系统的多进程，多线程进程间通讯线程并发等各种技术点，而这些技术并不是说最新的就是最好的，也不是非此即彼的选择，在做软件架构的时候，需要花费很大的精力来结合业务进行分析判断选择组合，这个过程同样很复杂。例如nginx可以用多进程也可以用多线程,JBoss采用的是多线程，redis用的是单进程，memcache用的是多线程。这些系统都实现了高性能，但内部的实现差异却非常大，每个软件各自根据自己的实际情况采用了适用于自己的方法。我们在进行自己的软件架构的时候也要进行这样的考虑。

## 集群复杂度

计算机硬件的性能虽然快速发展，但是比起软件业务的发展，那还真是差的远着呢。尤其是进入互联网时代后，业务的发展速度远远超过了硬件的发展速度。

例如2016年双11支付宝每秒峰值达到了12万笔支付。

再比如2017年春节微信红包收发红包每秒达到76万个。

要支持这种复杂度的业务，那肯定是要采用机器集群的方式了。像支付宝和微信这样的业务后台的机器数量，最少以万为单位计算。

通过大量节气的集群来提升性能，并不是简单的增加机器数量这么简单，需要让多台机器配合，有序的完成复杂的任务。

几种常见的集群方式。

### 1 任务分配法

就是每台机器都可以处理完整的业务任务，不同的任务被分配到不同的机器上执行，当然这个分配任务的任务也是由一台服务器完成的。如图所示增加一台服务器。
![两台服务器.png](https://i.loli.net/2020/03/16/Q5olvDKXxNUakp9.png)

此时复杂度一个明显的来源就是要增加一个任务分配器，而且这是必须不可缺少的，这个任务分配器有可能是交换机f5等也有可能是自己开发的，系统选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能成本和维护性，可用性等方面的因素。

其次，任务分配机和真正的业务服务及之间有连接和交互，需要选择合适的连接方式，并且对连接进行管理，比如说连接的建立，连接的检测连接中断后如何处理等。

再次任务分配器需要增加分配算法，究竟是轮巡还是按权重分配，又或者按照负载进行分配，这些都需要根据实际情况具体选择。

上面说的还只是简单的增加一台业务机器所造成的复杂度，我们假设单台业务的处理能力是5400每秒，那么这个架构理论上应该能够支撑1万次每秒的请求，但实际上性能一般按照8折计算，大约就是8000次左右。

如果我们要继续提升性能，比如每秒达到1万次请求。此时并不能通过简单的累加业务处理服务器来完成。因为当业务请求没达到每秒10万次的时候，单台任务分配器本身就会成为性能的瓶颈，这时候就需要多台任务分配器。

![多台服务器.png](https://i.loli.net/2020/03/16/iL7WghRGByqMt96.png)

比起前面说的两台服务器的架构，

1,现在这个架构可以说是复杂了非常多，任务分配器从一台变成了多台，这个变变化带来的复杂度，就是需要将不同的用户分配到不同的任务分配器上，常见的方法有DNS轮询，智能DNS，cdn，gsl设备等。

2,任务分配器和业务服务器的连接层简单的一对多变成了多对多的网状结构。

3,机器数量从三台扩展到了至少几十台，通常情况下周处理器比业务服务器少得多，由此引发的状态管理，故障处理复杂度也大大的增加。

上面说的两个例子其实说到一般的业务处理，但实际上业务涵盖的范围是很广的，可以只是完整的业务，也可以单指某个具体的任务，如存储，运算，缓存等都可以作为一项任务。因此存储系统，运算系统，缓存系统都可以按照任务分配的方式来搭建架构，另外任务分配器也并不一定只能是物理上存在的机器，或者一个独立运行的程序，也有可能是嵌入在其他程序中的算法，比如说memcache的集群架构。

### 2 任务分解法

前面说的任务分配的方法虽然能够突破，单击处理器性能的瓶颈，但是随着业务本身越来越复杂，单纯的只是通过任务分配的方式来扩展性能收益会越来越低，也就是说，增加机器的数量和性能的提升是不成正比的。比如增加了5倍的机器，但性能可能只提升了一倍。为了解决这个问题，就需要采用第2种方式，任务分解。

以微信的后台架构为例

![微信后台架构.png](https://i.loli.net/2020/03/16/yFtBORLThoMIZfu.png)

微信后台架构从逻辑上将各个子业务进行了拆分，包括接入注册登录消息，摇一摇漂流瓶其他业务(聊天视频朋友圈等)。

通过这种任务分解的方式，能够把原来大一统，但是复杂的业务系统还会很小而简单，但需要多个子系统配合的业务系统。从业务的角度看，任务分解，既不会减少功能，也不会减少代码量，但是它确实能切切实实的提高性能，原因主要有以下几点。

一 简单的系统更加容易做到高性能。

系统越简单影响性能点就越少，更加容易有针对性进行优化，复杂的情况下很难找到关键性能点，而且需要考虑验证的点太多，其次找到可优化的点之后，由于彼此间的牵扯耦合也很难以修改。

二 可以针对单个任务进行扩展。

不同的子系统划分完成之后，整个系统的性能瓶颈就很容易发现，然后我们就可以针对性的某个子系统进行性能的提升，不需要改动，整个系统风险小得多，另外也可以降低成本。例如假如说微信的用户数增长太快，注册登录子系统可能出现瓶颈，那我们只需要针对登录注册子系统进行优化或者是进行机器集群，而不用改动其他子系统。

那儿也并不是说对任务的进行子系统划分就可以一直提升整体性能的，也就是说责任划分的力度一定要控制好，如果拆分的过多的话，有可能会造成各个系统之间的彼此关联，彼此间的调用次数成指数即增加。总之我们还要综合各方面考虑子系统划分的力度问题。

总结 一是单台计算机内部为了高性能带来了复杂度；二是多台计算机集群为了高性能带来的复杂度。
