---
title: linux进程间通信之管道
date: 2020/3/8
comments: true
categories:
  - linux
tags:
  - 多进程
  - 通信
permalink: "6.2"
---
### 管道通信

管道是一种基于IPC的通信机制，通过调用系统函数pipe()来创建一个管道.

* 管道的特性:

1、管道本质上是一个伪文件——内核中的一个缓冲区
2、管道有两个文件描述符引用，一个表示读端，一个表示写端
3、数据流动是有方向的，必须从写端入，从读端出
4、管道的实现使用的是环形队列数据结构，借助内核缓冲区(4k)实现

* 管道的局限:

1、数据只能被读取一次，一旦被读走，就不在管道中存在了
2、由于管道采用半双工通信方式，因此，数据只能单向流动
3、只能在公共祖先(fork)的进程中使用
4、只能单向通信，双向通信需要两个管道

* pipe函数解释:

>int pipe(int pipefd[2]);   成功：0；失败：-1，设置errno

函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。
管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。

通常通过管道通信的过程如下:

1. 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。
2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。
3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。

### 使用管道需要特别注意的点

假设都是I/O阻塞操作，没有设置o-NONBLOCK标志

1、如果所有指向写端的文件操作符都关闭了，也就是写端的引用计数为0。此时如果还有进程从管道读端读数据，那么当
管道中剩余的数据被读取完后，回次read会返回0，就像读文件读到末尾了一样。

2、如果有指向管道写端的文件描述符没关闭，但是写端没有向管道中写入数据，这时候有进程从管道读数据，当读完剩余数据后，再次read回造成阻塞，直到管道中有新的数据被写入，函数才会读取数据并返回

3、如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。

4、如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。

### 代码示例

```C
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
    int fd[2];
    pipe(fd);
    pid_t pid = fork();

    if(pid == 0){
        //son
        sleep(3);
        close(fd[0]);//关闭读端
        write(fd[1],"hello",5);
        close(fd[1]);
        while(1){
            sleep(1);
        }
    }else if(pid > 0){
        //parent
        close(fd[1]);//关闭写端
        close(fd[0]);
        int status;
        wait(&status);
        if(WIFSIGNALED(status)){
            printf("killed by %d\n",WTERMSIG(status));
        }
        //父进程只是关闭读写两端，但是不退出
        while(1){
            sleep(1);
        }

        char buf[12]={0};
        while(1){

            int ret = read(fd[0],buf,sizeof(buf));
            if(ret == 0){
                printf("read over!\n");
                break;
            }
            if(ret > 0){
                write(STDOUT_FILENO,buf,ret);
            }
        }
    }
    return 0;
}
```
