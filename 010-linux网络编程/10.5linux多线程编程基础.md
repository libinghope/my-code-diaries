---
title: linux多线程编程基础
date: 2020/3/11
comments: true
categories:
  - linux
tags:
  - linux
  - 多线程
permalink: "6.5"
---
### 线程的定义

线程也成为轻量级进程，是进程中的一个运行实体，作为CPU的调度单位。一个进程由多个线程组成，线程与同属一个进程的其他的线程共享进程所拥有的全部资源。

同一进程内的所有线程除了共享全局变量外还共享：

1. 进程指令；
2. 大多数数据；
3. 打开的文件（即描述符）；
4. 信号处理函数和信号处置；
5. 当前工作目录；
6. 用户ID和组ID。

每个线程拥有各自的：

1. 线程ID；
2. 寄存器集合，包括程序计数器和栈指针
3. 栈（用于存放局部变量和返回地址）
4. errno；
5. 信号掩码；
6. 优先级。

结构上的不同可以让我们更加了解进程和线程的相异之处：

（1）进程是资源分配的基本单位；线程与资源分配无关，它属于某一个进程，并与进程内的其他线程共享进程的资源。

（2）当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。

（3）线程只有相关堆栈（系统栈或用户栈）寄存器和线程控制块组成。寄存器用来存储线程内的局部变量，但不能存储其他线程的相关变量。

（4）进程切换时涉及有关资源指针的保存和地址空间的变化；线程切换时，由于处于同一进程内，所以不涉及资源信息的保存和地址空间的变化，从而减少了操作系统的时间开销

### 线程相关的函数

1.pthread_create函数，创建线程

int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*func)(void *), void *arg);

      pthread_t *tid：一个进程内的各个线程是由线程ID标识的，如果新线程创建成功，返回tid指针。

      const pthread_attr_t *attr：每个线程有多个属性，包括优先级、初始栈大小、是否是一个守护线程等等。

      void *(*func)(void *)：线程启动函数，线程从调用这个函数开始，或显示结束（调用pthread_exit()），或隐式结束（让该函数返回）。

      void *arg：线程执行func函数的传递参数。

2.pthread_join函数，等待一个线程终止

int pthread_join(pthread_t *tid, void **status);

      void **status：二级指针，如果status指针非空，那么所等待线程的返回值将存放在status指向的位置。

3.pthread_self函数，返回线程ID

int pthread_self(void);
      跟进程比较，相当于getpid。

4.pthread_detach函数，线程分离

int pthread_detach(pthread_t tid);　　

      线程或者是可汇合的（joinable），或者是脱离的（detach）。当可汇合的线程终止时，线程ID和退出状态将保留，知道另外一个线程调用pthread_join。脱离的线程终止时，释放所有的资源，因此我们不能等待它终止。若要一个线程知道另一个线程的终止时间，我们就要保留第二个线程的可汇合性。

5.pthread_exit函数，线程终止

int pthread_exit(void **status);　　

      若线程未脱离，那么它的线程ID和退出状态将保留到另外一个线程调用pthread_join为止。

### 相比进程使用多线程带来的好处

在传统的UNIX模型中，当一个进程需要另一个实体来完成某事，它就fork一个子进程并让子进程去处理。但是fork的调用有如下缺点：

（1）fork的代价是昂贵的。fork要把父进程的内存印象复制到子进程，并在子进程中复制所有描述符等。

（2）fork返回之后父子进程之间信息的传递需要进程通信机制。调用fork之前父进程向尚未存在的子进程传递信息相当容易，因为子进程将从父进程数据空间及所有描述符的一个副本开始运行，但是从子进程向父进程返回信息却比较费力。

针对这两点，多线程技术相应而生，它具有如下优越性：

（1）它是一种非常"节俭"的多任务操作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。

（2）线程间方便的通信更加方便。由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。但是，同一进程内的所有线程共享相同的全局内存，这样线程之间的通信就变得相当简单，随之而来的就是同步问题。
