---
date: 2020/3/13
comments: true
categories:
  - 软件架构
tags:
  - 架构
  - 复杂度
permalink: "5.6"
title: 低成本、安全、规模等造成的复杂度
---
## 低成本

当我们的架构方案只涉及几台或者十几台服务器时，一般情况下成本并不是我们重点关注的目标，但如果架构方案涉及几百上千甚至上万台服务器，成本就会变成一个非常重要的架构设计考虑点。例如，A 方案需要 10000 台机器，B 方案只需要 8000 台机器，单从比例来看，也就节省了 20% 的成本，但从数量来看，B 方案能节省 2000 台机器，1 台机器成本预算每年大约 2 万元，这样一年下来就能节省 4000 万元，4000 万元成本不是小数目，给 100 人的团队发奖金每人可以发 40 万元了，这可是算得上天价奖金了。通过一个架构方案的设计，就能轻松节约几千万元，不但展现了技术的强大力量，也带来了可观的收益，对于技术人员来说，最有满足感的事情莫过于如此了。  
当我们设计“高性能”“高可用”的架构时，通用的手段都是增加更多服务器来满足“高性能”和“高可用”的要求；而低成本正好与此相反，我们需要减少服务器的数量才能达成低成本的目标。因此，低成本本质上是与高性能和高可用冲突的，所以低成本很多时候不会是架构设计的首要目标，而是架构设计的附加约束。也就是说，我们首先设定一个成本目标，当我们根据高性能、高可用的要求设计出方案时，评估一下方案是否能满足成本目标，如果不行，就需要重新设计架构；如果无论如何都无法设计出满足成本要求的方案，那就只能找老板调整成本目标了。

低成本给架构设计带来的主要复杂度体现在，往往只有“创新”才能达到低成本目标。这里的“创新”既包括开创一个全新的技术领域（这个要求对绝大部分公司太高），也包括引入新技术，如果没有找到能够解决自己问题的新技术，那么就真的需要自己创造新技术了。  

类似的新技术例子很多:  

* NoSQL（Memcache、Redis 等）的出现是为了解决关系型数据库无法应对高并发访问带来的访问压力。
* 全文搜索引擎（Sphinx、Elasticsearch、Solr）的出现是为了解决关系型数据库 like 搜索的低效的问题。
* Hadoop 的出现是为了解决传统文件系统无法应对海量数据存储和计算的问题。

再举几个业界类似的例子

* Facebook 为了解决 PHP 的低效问题，刚开始的解决方案是 HipHop PHP，可以将 PHP 语言翻译为 C++ 语言执行，后来改为 HHVM，将 PHP 翻译为字节码然后由虚拟机执行，和 Java 的 JVM 类似。
* 新浪微博将传统的 Redis/MC + MySQL 方式，扩展为 Redis/MC + SSD Cache + MySQL 方式，SSD Cache 作为 L2 缓存使用，既解决了 MC/Redis 成本过高，容量小的问题，也解决了穿透 DB 带来的数据库访问压力（来源：http://www.infoq.com/cn/articles/weibo-platform-archieture ）。
* Linkedin 为了处理每天 5 千亿的事件，开发了高效的 Kafka 消息系统。
* 其他类似将 Ruby on Rails 改为 Java、Lua + redis 改为 Go 语言实现的例子还有很多。

以上说的基本上都是一线互联网”大厂”的例子，其实也只有这样的大厂才有可能真正的创新，毕竟创新的成本太高，一般的小公司都缺乏相对应的资源，技术和人才。所以小公司通常就只能引入新技术来降低成本。然而无论创新还是引入，都需要去熟悉新技术，并且将新技术与已有技术结合起来；创造新技术则更是要求创造全新的理念和技术，并且新技术跟旧技术相比，需要有质的飞跃。

## 安全

安全本身是一个庞大而又复杂的技术领域，并且一旦出问题，对业务和企业形象影响非常大。例如：
* 2016 年雅虎爆出史上最大规模信息泄露事件，逾 5 亿用户资料在 2014 年被窃取。
* 2016 年 10 月美国遭史上最大规模 DDoS 攻击，东海岸网站集体瘫痪。
* 2013 年 10 月，为全国 4500 多家酒店提供网络服务的浙江慧达驿站网络有限公司，因安全漏洞问题，致 2 千万条入住酒店的客户信息泄露，由此导致很多敲诈、家庭破裂的后续事件。
  
就安全而言，又可以分为功能安全和架构安全。  
功能安全主要指的就是软件功能本身不能有漏洞，如常见的 XSS 攻击、CSRF 攻击、SQL 注入、Windows 漏洞、密码破解等。  
架构安全主要是指别有用心的人恶意攻击，如DDos攻击。  

软件达到一定的规模，一定存在着漏洞；而通常预防架构攻击的防火墙太昂贵，而且轻易用不上，通常情况下企业更多地是依靠运营商或者云服务商强大的带宽和流量清洗的能力来解决，较少自己来设计和实现。

## 规模

很多企业级的系统，既没有高性能要求，也没有双中心高可用要求，也不需要什么扩展性，但往往我们一说到这样的系统，很多人都会脱口而出：这个系统好复杂！为什么这样说呢？关键就在于这样的系统往往功能特别多，逻辑分支特别多。特别是有的系统，发展时间比较长，不断地往上面叠加功能，后来的人由于不熟悉整个发展历史，可能连很多功能的应用场景都不清楚，或者细节根本无法掌握，面对的就是一个黑盒系统，看不懂、改不动、不敢改、修不了，复杂度自然就感觉很高了。程序员最头疼的三个字——改需求。  

**规模带来复杂度的主要原因就是“量变引起质变”**，当数量超过一定的阈值后，复杂度会发生质的变化。常见的规模带来的复杂度有：

1. 功能越来越多，导致系统复杂度指数级上升。
   例如，某个系统开始只有 3 大功能，后来不断增加到 8 大功能，虽然还是同一个系统，但复杂度已经相差很大了，具体相差多大呢？  
![](https://i.loli.net/2020/03/17/Vucy74vTXxDIZLC.png “”)  
如上图所示，可以直观的看出，随着功能的增加，功能之间彼此勾连耦合，复杂度成指数级增长。

2. 数据越来越多，系统复杂度发生质变
   与功能类似，系统数据越来越多时，也会由量变带来质变，最近几年火热的“大数据”就是在这种背景下诞生的。大数据单独成为了一个热门的技术领域，主要原因就是数据太多以后，传统的数据收集、加工、存储、分析的手段和工具已经无法适应，必须应用新的技术才能解决。目前的大数据理论基础是 Google 发表的三篇大数据相关论文，其中 Google File System 是大数据文件存储的技术理论，Google Bigtable 是列式数据存储的技术理论，Google MapReduce 是大数据运算的技术理论，这三篇技术论文各自开创了一个新的技术领域。  
   即使我们的数据没有达到大数据规模，数据的增长也可能给系统带来复杂性。最典型的例子莫过于使用关系数据库存储数据，我以 MySQL 为例，MySQL 单表的数据因不同的业务和应用场景会有不同的最优值，但不管怎样都肯定是有一定的限度的，一般推荐在 5000 万行左右。如果因为业务的发展，单表数据达到了 10 亿行，就会产生很多问题，例如：
   * 添加索引会很慢，可能需要几个小时，这几个小时内数据库表是无法插入数据的，相当于业务停机了。
   * 修改表结构和添加索引存在类似的问题，耗时可能会很长。
   * 即使有索引，索引的性能也可能会很低，因为数据量太大。
   * 数据库备份耗时很长。
  因此，当 MySQL 单表数据量太大时，我们必须考虑将单表拆分为多表，这个拆分过程也会引入更多复杂性，例如：拆表的规则是什么？拆表之后之前的业务代码如何处理。拆完之后的查询如何处理？类似的问题还有很多。

综上可以看出，做软件架构时候要考虑成本问题(这对很多公司来说可能是最重要的问题)，要考虑安全问题，要考虑未来业务规模的问题。这些因素都给软件带来了非常大的复杂度。
